## ManGogan

### 1. GPU渲染关于缓冲区的一些概念

[参考文章](https://www.linuxidc.com/Linux/2014-07/104847.htm)

- 深度: 该像素点在3d世界离摄像机的距离(绘制坐标), Z值越大, 离相机越远.深度缓存精度用24位就可以了.

- 颜色缓冲区(COLOR_BUFFER), 就是帧缓冲区(FRAME_BUFFER), 需要将每一个像素都写入该缓冲区, 然后再渲染到屏幕
- 深度缓冲区(DEPTH_BUFFER), Z缓冲区, 与帧缓冲区对应, 用于记录帧缓冲区每个像素的深度值, 通过深度测试确定像素之间的遮挡关系, 保证渲染的正确
- 模板缓冲区(STENCIL_BUFFER): 与深度缓冲大小相同, 通过设置模板缓冲每个像素的值, 可以在渲染的时候, 指定只渲染某些元素,达到一些特殊效果观察平面(近剪裁面)

- 深度缓冲区原理: 
  1. 首先使用gl.clear将所有像素的深度值设为最大(一般是远裁剪面)
  2. 然后在场景中以任意次序绘制所有物体.
  3. 再然后, opengl会计算这些表面和观察平面的距离, 如果启动了深度缓冲区, 在绘制每个像素之前, OpenGL会将它的深度值和已经存储在这个像素的深度值比较, 小的会取代, 大的颜色值和深度值被舍弃.
  4. 启动深度缓冲区, 需要执行gl.enable, 而且在每次绘制场景前, 先清除深度缓冲区, gl.clear(GL_DEPTH_BUFFER_BIT)

- 禁用深度: gl.depthMask(GL_FALSE)
- 半透明物体的绘制: 在绘制半透明物体前需要使用gl.depthMash(GL_FALSE)将深度缓冲区设置为只读, 否则可能出现画面错误, 因为绘制透明物体将使用混色.

### 2. 学习了TypeScript的语法
  - [中文参考文档](https://ts.xcatliu.com/advanced/generics#jian-dan-de-li-zi)
  - 虽然不能熟练写, 但是基本上能看懂.

## Volankey

### 1.2019年09月04日遇见一个bug
```javasctipt
  <n-advance-table
      ref="table"
      :columns="columns"
      :data="data"
      :loading="loading"
      @on-page-change="onPageChange"
      :pagination="{total:data.length,limit:10}"
      >
     <n-button
      slot="table-operation-search-right"
      style="margin-left:12px;margin-bottom:8px;"
      round
      size="small"
      @click="openCreateArea"
      >{{ $t("New Type") }}</n-button
    >
  </n-advance-table>
   <Input
    v-model="newServiceTypeName"
    :placeholder="$t('Service type name, initial letter suggested uppercase')"
  />
```
组件props外部直接传入一个对象,组件内部使用computed计算某个属性的时候依赖了这个prop,当父元素刷新的时候(兄弟组件input,绑定v-model输入文字),会触发组件内部的computed计算

原因:v-model更新,同时会触发重新渲染组件,这时table组件computed中依赖了pagination,那么pagination必然会返回一个新的对象,触发相关依赖的computed
